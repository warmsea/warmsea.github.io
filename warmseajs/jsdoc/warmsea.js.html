<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: warmsea.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: warmsea.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*!
 * warmsea JavaScript Library v0.3.0
 *
 * Copyright 2009, 2014 Su Su
 * Released under the MIT license
 *
 * Date: 2014-05-03
 */

(function(global) {
  'use strict';

  /**
   * This will be the global &lt;code>warmsea&lt;/code> namespace.
   *
   * @namespace
   * @alias warmsea
   */
  var w = {};

  /**
   * A function with no operation.
   */
  w.noop = function() {
  };

  /**
   * An identity function.
   *
   * @param {*} x A value.
   * @returns{*} &lt;code>x&lt;/code> itself.
   */
  w.identity = function(x) {
    return x;
  };

  /**
   * An unimplemented function that throws an error.
   */
  w.unimplemented = function() {
    var msg = 'Unimplemented function.';
    if (w.isFunction(w.error)) {
      w.error(msg);
    } else {
      throw new Error(msg);
    }
  };

  /**
   * Throws an Error.
   *
   * @function
   * @param {string} msg The error message.
   * @throws {Error} An error with a message.
   */
  w.error = w.error || function(msg) {
    throw new Error(msg);
  };

  /**
   * The default compare function
   *
   * @param {*} a A value.
   * @param {*} b Another value.
   * @returns{number} 1, if a &amp;gt; b; -1, if a &amp;lt; b; 0, otherwise.
   */
  w.cmp = function(a, b) {
    return a > b ? 1 : a &lt; b ? -1 : 0;
  };

  /**
   * Returns the keys of an object.
   *
   * Samples:
   *
   * Code: w.keys(['a', 'b', 'c']);
   * Result: ["0", "1", "2"]
   *
   * Code: w.keys({a:1, b:2, c:3});
   * Result: ["a", "b", "c"]
   *
   * @param {object} obj An Object.
   * @returns{Array} The keys of the object.
   */
  w.keys = function(obj) {
    var keys = [];
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        keys.push(k);
      }
    }
    return keys;
  };

  /**
   * Returns the values of an object.
   * No deep copy. Equal sign (=) is used to cope the value.
   *
   * Samples:
   *
   * Code: w.values(['a', 'b', 'c']);
   * Result: ["a", "b", "c"]
   *
   * Code: w.values({a:1, b:'hello', c:[1,2,3]});
   * Result: [1, "hello", [1, 2, 3]]
   *
   * @param {object} obj An object.
   * @returns{Array} The values of the object.
   */
  w.values = function(obj) {
    var values = [];
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        values.push(obj[k]);
      }
    }
    return values;
  };

  /**
   * Generate an array.
   * This is the port of the Python range().
   */
  w.range = function(start, stop, step) {
    if (arguments.length &lt;= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var i = 0, len = Math.max(Math.ceil((stop - start) / step), 0);
    var range = new Array(len);
    while (i &lt; len) {
      range[i++] = start;
      start += step;
    }

    return range;
  };

  /**
   * In-place stable sort.
   *
   * @param {Array} arr The array to be sorted.
   * @param {function} cmp The compare function; by default, it's w.cmp。
   * @return {Array} The sorted array.
   */
  w.sort = function(arr, cmp) {
    cmp = cmp || w.cmp;
    var i;
    var len = arr.length;
    for (i = 0; i &lt; len; ++i) {
      // _wssi stands for Warmsea Stable Sort Id
      arr[i]._wssi = i;
    }
    arr.sort(function(a, b) {
      return cmp(a, b) || a._wssi - b._wssi;
    });
    for (i = 0; i &lt; len; ++i) {
      delete arr[i]._wssi;
    }
    return arr;
  };

  /**
   * Return the smallest value.
   *
   * @param {function} cmp A optional compare function.
   * @param {*} values Values as an array or a list of arguments.
   * @return {*} The smallest value.
   */
  w.min = function(/* [cmp,] (values_array | value1,value2,value3,...) */) {
    if (!arguments.length) {
      return undefined;
    }
    var cmp, values;
    if (w.isFunction(arguments[0])) {
      cmp = arguments[0];
      values = Array.prototype.slice.call(arguments, 1);
    } else {
      cmp = w.cmp;
      values = Array.prototype.slice.call(arguments, 0);
    }
    if (!values.length) {
      return undefined;
    }
    var data = w.isArray(values[0]) ? values[0] : values;
    var min = data[0];
    for (var i = 1, len = data.length; i &lt; len; ++i) {
      if (cmp(min, data[i]) > 0) {
        min = data[i];
      }
    }
    return min;
  };

  /**
   * Return the largest value.
   *
   * @param {function} cmp A optional compare function.
   * @param {*} values Values as an array or a list of arguments.
   * @return {*} The largest value.
   */
  w.max = function(/* [cmp,] (values_array | value1,value2,value3,...) */) {
    if (!arguments.length) {
      return undefined;
    }
    var cmp, values;
    if (w.isFunction(arguments[0])) {
      cmp = arguments[0];
      values = Array.prototype.slice.call(arguments, 1);
    } else {
      cmp = w.cmp;
      values = Array.prototype.slice.call(arguments, 0);
    }
    if (!values.length) {
      return undefined;
    }
    var data = w.isArray(values[0]) ? values[0] : values;
    var max = data[0];
    for (var i = 1, len = data.length; i &lt; len; ++i) {
      if (cmp(max, data[i]) &lt; 0) {
        max = data[i];
      }
    }
    return max;
  };

  /**
   * Cast a value to a Boolean.
   *
   * @param {*} value A value.
   * @return {boolean} The boolean value.
   */
  w.bool = function(value) {
    var v = value;
    if (w.isObject(v) &amp;&amp; '__bool__' in v) {
      return w.bool(w.isFunction(v.__bool__) ? v.__bool__() : v.__bool__);
    } else {
      return !!value;
    }
  };

  /**
   * Cast a value to an Integer.
   *
   * @param {*} value A value.
   * @param {number} radix An integer between 2 and 32.
   * @return {number} The integer value.
   */
  w.i = function(value, radix) {
    var v = value;
    if (v === true) {
      return 1;
    } else if (w.isObject(v) &amp;&amp; '__int__' in v) {
      return w.i(w.isFunction(v.__int__) ? v.__int__() : v.__int__, radix);
    } else if (!radix &amp;&amp; w.isString(v) &amp;&amp; (v.indexOf('0x') === 0 || v.indexOf('0X') === 0)) {
      return parseInt(v, 16);
    } else if (!radix || radix === 10) {
      return Math.round(parseFloat(v));
    } else {
      return parseInt(v, radix);
    }
  };

  /**
   * Cast a value to a Float.
   *
   * @param {*} value A value.
   * @return {number} The float value.
   */
  w.f = function(value) {
    var v = value;
    if (v === true) {
      return 1.0;
    } else if (w.isObject(v) &amp;&amp; '__float__' in v) {
      return w.f(w.isFunction(v.__float__) ? v.__float__() : v.__float__);
    } else {
      return parseFloat(v);
    }
  };

  /**
   * Cast a value to a String.
   *
   * @param {*} value A value.
   * @return {string} The string value.
   */
  w.str = function(value) {
    var v = value;
    if (w.isObject(v) &amp;&amp; '__str__' in v) {
      return w.str(w.isFunction(v.__str__) ? v.__str__() : v.__str__);
    } else {
      return String(value);
    }
  };

  /**
   * Cast a value to an Array.
   * &lt;p>
   * If &lt;code>value&lt;/code> is &lt;code>undefined&lt;/code> or &lt;code>null&lt;/code>, an empty array will be returned.
   *
   * @param {*} value A value.
   * @return {Array} The array value.
   */
  w.array = function(value) {
    if (w.isArray(value)) {
      return value;
    } else if (value === undefined || value === null) {
      return [];
    } else {
      return [value];
    }
  };

  /**
   * Test whether a value is a number.
   *
   * @param {*} value A value.
   * @return {boolean} &lt;code>true&lt;/code>, if &lt;code>value&lt;/code> is a string; &lt;code>false&lt;/code>, otherwise.
   */
  w.isNumber = function(value) {
    return typeof value === 'number';
  };

  /**
   * Test whether a value is an integer.
   * &lt;p>
   * JavaScript has only one number type, that is 64-bit floating-point number. So we test whether the value is an
   * integer in that system. Which means 1.0 and 1 are both integers, but 9007199254740994 is not an integer because it
   * exceeds the max integer value a 64-bit floating-point number can present (±2^53).
   *
   * @param {*} value A value.
   * @return {boolean} &lt;code>true&lt;/code>, if &lt;code>value&lt;/code> is a string; &lt;code>false&lt;/code>, otherwise.
   */
  w.isInt = function(value) {
    return typeof value === 'number' &amp;&amp; value % 1 === 0 &amp;&amp; value >= -9007199254740992 &amp;&amp; value &lt;= 9007199254740992;
  };

  /**
   * Test whether a value is a string.
   *
   * @param {*} value A value.
   * @return {boolean} &lt;code>true&lt;/code>, if &lt;code>value&lt;/code> is a string; &lt;code>false&lt;/code>, otherwise.
   */
  w.isString = function(value) {
    return typeof value === 'string';
  };

  /**
   * Test whether a value is an array.
   *
   * @param {*} value A value.
   * @return {boolean} &lt;code>true&lt;/code>, if &lt;code>value&lt;/code> is an array; &lt;code>false&lt;/code>, otherwise.
   */
  w.isArray = function(value) {
    return value instanceof Array;
  };

  /**
   * Test whether a value is a function.
   *
   * @param {*} value A value.
   * @return {boolean} &lt;code>true&lt;/code>, if &lt;code>value&lt;/code> is a function; &lt;code>false&lt;/code>, otherwise.
   */
  w.isFunction = function(value) {
    return typeof value === 'function';
  };

  /**
   * Test whether a value is a plain object.
   * &lt;p>
   * ATTENSION: I'm not pretty sure whether this function works everywhere. Can anyone help me?
   * &lt;p>
   * A plain object is typically an object defined with &lt;code>{}&lt;/code> or &lt;code>new Object&lt;/code>.
   *
   * @param {*} value A value.
   * @return {boolean} &lt;code>true&lt;/code>, if &lt;code>value&lt;/code> is a plain object; &lt;code>false&lt;/code>, otherwise.
   */
  w.isPlainObject = function(value) {
    if (String(value) !== '[object Object]') {
      return false;
    }
    try {
      if (!value.constructor.prototype.hasOwnProperty('isPrototypeOf')) {
        return false;
      }
    } catch (e) {
      return false;
    }
    return true;
  };

  /**
   * Test whether a value is an object.
   * &lt;p>
   * &lt;code>undefined&lt;/code>, &lt;code>null&lt;/code>, numbers, strings won't pass this test, everything else will.
   * &lt;p>
   * ATTENSION: &lt;code>typeof null&lt;/code> is &lt;code>"object"&lt;/code>, but &lt;code>warmsea.isObject(null)&lt;/code> returns
   * &lt;code>false&lt;/code>. Because using a &lt;code>null&lt;/code> object is always error-prone.
   * &lt;p>
   * Arrays pass both &lt;code>warmsea.isArray()&lt;/code> and &lt;code>warmsea.isObject()&lt;/code>.
   *
   * @param {*} value A value.
   * @return {boolean} &lt;code>true&lt;/code>, if &lt;code>value&lt;/code> is an object; &lt;code>false&lt;/code>, otherwise.
   */
  w.isObject = function(value) {
    return value !== null &amp;&amp; typeof value === 'object';
  };

  /**
   * Pad a string to a given length by adding leading characters.
   *
   * @param {number|string} value The value; usually a number.
   * @param {int} length The wanted length. If not given, it's 2.
   * @param {string} leading The leading character. If not given, it's '0'.
   */
  w.pad = function(value, length, leading) {
    value = w.str(value);
    length = w.max(0, length === undefined ? 2 : length, value.length);
    leading = w.str(leading || '0');
    var a = new Array(Math.ceil((length - value.length) / leading.length) + 1);
    return a.join(leading).substring(0, length - value.length) + value;
  };

  /**
   * Format a string.
   * &lt;p>
   * It is similar to the &lt;code>sprintf()&lt;/code> in the C language.
   * &lt;p>
   * A conversion specifiers is of the following format: &lt;br>
   * %[mapping_key][flags][width][.precision][length]conversion_type
   * &lt;p>
   * A mapping key is a parenthesized string (for example, &lt;code>(year)&lt;/code>,
   * parenthesis is not allowed inside it).
   * &lt;p>
   * Available flags are listed below:&lt;br>
   * &lt;table>&lt;thead>
   * &lt;tr>
   * &lt;th>Flag
   * &lt;th>Meaning&lt;/th>
   * &lt;tbody>
   * &lt;tr>
   * &lt;td>&lt;code>#&lt;/code>
   * &lt;td>Use the "alternate form".
   * &lt;tr>
   * &lt;td>&lt;code>0&lt;/code>
   * &lt;td>zero padding before a number.
   * &lt;tr>
   * &lt;td>&lt;code>-&lt;/code>
   * &lt;td>(Overrides "0" flag.) The converted value is left adjusted.
   * &lt;tr>
   * &lt;td>&lt;code>(a space)&lt;/code>
   * &lt;td>A space will precede a positive number or an empty string produced by
   * a signed conversion.
   * &lt;tr>
   * &lt;td>&lt;code>+&lt;/code>
   * &lt;td>(Overrides "space" flag.) A sign character ("+" or "-") will precede a
   * number.&lt;/td>
   * &lt;/table>
   * &lt;p>
   * "width" is an integer indicates the minimum field width, or an "*". If it
   * is an "*", the width is the next &lt;code>arg&lt;/code>, and the value to
   * convert comes after the width and the optional precision.
   * &lt;p>
   * "precision" is a dot (".") followed by an integer indicates the precision,
   * or an "*". If it is an "*", the precision is the next &lt;code>arg&lt;/code>,
   * and the value to convert comes after the precision. The precision
   * determines the number of digits after the decimal point and defaults to 6.
   * &lt;p>
   * "length" is one of "h", "l" or "L". But it is ignored as it is not
   * necessary for JavaScript.
   * &lt;p>
   * Available conversion types are listed below:&lt;br>
   * &lt;table>&lt;thead>
   * &lt;tr>
   * &lt;th>Conversion
   * &lt;th>Meaning
   * &lt;th>Note&lt;/th>
   * &lt;tbody>
   * &lt;tr>
   * &lt;td>&lt;code>d&lt;/code>
   * &lt;td>Decimal.
   * &lt;td>
   * &lt;tr>
   * &lt;td>&lt;code>o&lt;/code>
   * &lt;td>Octal.
   * &lt;td>"Alternate form" adds leading zero ("0").
   * &lt;tr>
   * &lt;td>&lt;code>x&lt;/code>
   * &lt;td>Lowercase hexadecimal.
   * &lt;td>"Alternate form" adds leading "0x".
   * &lt;tr>
   * &lt;td>&lt;code>X&lt;/code>
   * &lt;td>Uppercase hexadecimal.
   * &lt;td>"Alternate form" adds leading "0X".
   * &lt;tr>
   * &lt;td>&lt;code>f&lt;/code>
   * &lt;td>Floating point decimal format.
   * &lt;td>"Alternate form" ensures a decimal point, even if no digits follow it.
   * &lt;tr>
   * &lt;td>&lt;code>s&lt;/code>
   * &lt;td>String
   * &lt;td>
   * &lt;tr>
   * &lt;td>&lt;code>%&lt;/code>
   * &lt;td>A "%" character.
   * &lt;td>
   * &lt;tr>
   * &lt;td>&lt;code>/&lt;/code>
   * &lt;td>A "/" character.&lt;/td>
   * &lt;/table>
   * &lt;p>
   * All integer values are converted with &lt;code>warmsea.int()&lt;/code>. And
   * &lt;code>warmsea.float()&lt;/code> for floats, &lt;code>warmsea.string()&lt;/code>
   * for strings.
   *
   * @function
   * @param {string|function} format the format string.
   * @param {...*} args Arguments one by one, or a list.
   * @return {string} The formatted string.
   */
  w.format = (function(w) {

    var f = function(format /* , args_array | args_map | arg1, arg2,  ... */) {
      if (!arguments.length) {
        return '';
      }
      format = func2str(arguments[0]);

      var params;
      if (w.isArray(arguments[1])) {
        params = arguments[1];
      } else if (w.isPlainObject(arguments[1])) {
        params = arguments[1];
      } else {
        params = Array.prototype.slice.call(arguments, 1);
      }

      var converter = new FormatConverter(params);

      var specifiers = /%(?:\((.*?)\))?([#|0|\-| |\+]+)?(\d+|\*)?(?:.(\d+|\*))?(?:[h|l|L])?(.)?/g;

      format = format.replace(specifiers, function() {
        return FormatConverter.prototype.convert.apply(converter, arguments);
      });

      return format;
    };

    /**
     * Convert a function into a (multi-line) string.
     *
     * @see warmsea#format
     */
    var func2str = function(func) {
      if (w.isString(func)) {
        return func;
      } else if (!w.isFunction(func)) {
        return w.str(func);
      }

      var lines = w.str(func).split(/\r?\n/);
      var i = 0, j = 0, len = lines.length;
      var startIndex, endIndex;
      var endTag, options = {};
      var dent = null;

      // Find the start line.
      while (i &lt; len) {
        var start = lines[i++].match(/^[ \t]*\/\*!?&lt;&lt;&lt;(\w+)(?:;(.+)?)?$/);
        if (!start) {
          continue;
        }
        startIndex = i;
        endTag = start[1];
        var optionTags = (start[2] || '').split(/[ \t]*,[ \t]*/);
        for (j = 0; j &lt; optionTags.length; ++j) {
          var tag = optionTags[j].toLowerCase().split(/-(.*)/);
          if (tag[0]) {
            options[tag[0]] = tag[1] || true;
          }
        }
        break;
      }
      if (!startIndex) {
        w.error('Format failed: start line missing');
      }

      // The default WS option is "OUTDENT".
      options.ws = options.ws || 'outdent';

      var result = [];

      // Find the end line.
      while (i &lt; len) {
        var line = lines[i];
        if (line.match(new RegExp('^[ \\t]*' + endTag + '\\*\\/'))) {
          endIndex = i;
          break;
        }
        i++;
        // Count the dent here.
        if (options.ws === 'outdent') {
          var match = line.match(/^([ \t]*).*$/);
          var cur = match[1];
          if (dent === null) {
            dent = cur;
          } else {
            j = 0;
            while (j &lt; dent.length &amp;&amp; j &lt; cur.length &amp;&amp; dent[j] === cur[j]) {
              j++;
            }
            if (dent.length > j) {
              dent = dent.substring(0, j);
            }
          }
        }
        result.push(line);
      }
      if (!endIndex) {
        w.error('Format failed: end line missing');
      }

      var wsFunc;
      switch (options.ws) {
        case 'outdent':
          wsFunc = function(s) {
            return s.substring(dent.length);
          };
          break;
        case 'keep':
          wsFunc = w.identity;
          break;
        case 'trim':
          wsFunc = function(s) {
            return s.trim();
          };
          break;
        default:
          w.error('Format failed: Unsupported WS option');
      }

      for (i = 0, len = result.length; i &lt; len; ++i) {
        result[i] = wsFunc(result[i]);
      }

      return result.join('\n');
    };

    /**
     * Convertor for &lt;code>format()&lt;/code> function.
     *
     * @see warmsea#format
     */
    var FormatConverter = function(params) {
      this.params = params || [];
      this.index = 0;
    };

    /**
     * Convert a specifier into wanted string.
     *
     * @see warmsea#format
     */
    FormatConverter.prototype.convert = function(specifier, key, flags, width, precision, type, position) {
      if (type === undefined) {
        w.error('format incomplete specifier "%s" in position (%d).', specifier, position);
      }
      if (!this.convertors.hasOwnProperty(type)) {
        w.error('format unsupported type "%s" in position (%d)', type, position);
      }

      var next;

      if (width === '*') {
        next = this.index++;
        if (!this.params.hasOwnProperty(next)) {
          w.error('format key error "%s" in position (%d).', key, position);
        }
        width = this.params[next];
      }
      width = width || 0;

      if (precision === '*') {
        next = this.index++;
        if (!this.params.hasOwnProperty(next)) {
          w.error('format key error "%s" in position (%d).', key, position);
        }
        precision = this.params[next];
      }
      if (precision === undefined) {
        precision = 6;
      }

      if (type === '%' || type === '/') {
        return type;
      }

      key = key === undefined ? this.index++ : key;
      if (!this.params.hasOwnProperty(key)) {
        w.error('format key error "%s" in position (%d).', key, position);
      }
      var value = this.params[key];

      flags = flags || '';
      flags = {
        '#': flags.indexOf('#') >= 0,
        '0': flags.indexOf('0') >= 0 &amp;&amp; flags.indexOf('-') &lt; 0,
        '-': flags.indexOf('-') >= 0,
        ' ': flags.indexOf(' ') >= 0 &amp;&amp; flags.indexOf('+') &lt; 0,
        '+': flags.indexOf('+') >= 0
      };

      return this.convertors[type](value, flags, width, precision);
    };

    /**
     * The convertors of each type.
     */
    FormatConverter.prototype.convertors = {
      'd': function(value, flags, width /*, precision */) {
        return FormatConverter.prototype.convertors.ic('d', value, flags, width);
      },
      'o': function(value, flags, width /*, precision */) {
        return FormatConverter.prototype.convertors.ic('o', value, flags, width);
      },
      'x': function(value, flags, width /*, precision */) {
        return FormatConverter.prototype.convertors.ic('x', value, flags, width);
      },
      'X': function(value, flags, width /*, precision */) {
        return FormatConverter.prototype.convertors.ic('X', value, flags, width);
      },
      'f': function(value, flags, width, precision) {
        value = w.f(value);
        var sign = value &lt; 0 ? '-' : (flags['+'] ? '+' : flags[' '] ? ' ' : '');
        value = Math.abs(value).toFixed(precision);
        if (flags['#'] &amp;&amp; precision === 0) {
          value += '.';
        }
        var gap = w.max(0, width - value.length - sign.length);
        if (flags['-']) {
          return sign + value + w.pad('', gap, ' ');
        } else if (flags['0']) {
          return sign + w.pad('', gap, '0') + value;
        } else {
          return w.pad('', gap, ' ') + sign + value;
        }
      },
      's': function(value, flags, width /*, precision */) {
        value = w.str(value);
        var gap = w.max(0, width - value.length);
        if (flags['-']) {
          return value + w.pad('', gap, ' ');
        } else {
          return w.pad('', gap, ' ') + value;
        }
      },
      '%': function() {
        this.index--;
        return '%';
      },
      '/': function() {
        this.index--;
        return '/';
      },
      'ic': function(type, value, flags, width) {
        value = w.i(value);
        var sign = value &lt; 0 ? '-' : (flags['+'] ? '+' : flags[' '] ? ' ' : '');
        var prefix = flags['#'] ? {
          'd': '',
          'o': '0',
          'x': '0x',
          'X': '0X'
        }[type] : '';
        value = Math.abs(value).toString({
          'd': 10,
          'o': 8,
          'x': 16,
          'X': 16
        }[type]);
        var gap = w.max(0, width - prefix.length - value.length - sign.length);
        var result = '';
        if (flags['-']) {
          result = sign + prefix + value + w.pad('', gap, ' ');
        } else if (flags['0']) {
          result = sign + prefix + w.pad('', gap, '0') + value;
        } else {
          result = w.pad('', gap, ' ') + sign + prefix + value;
        }
        if (type === 'X') {
          result = result.toUpperCase();
        }
        return result;
      }
    };

    return f;

  })(w);


  /**
   * Choose a random floating-point number in the range of [0.0, 1.0).
   *
   * @return {number} A floating-point number in the range of [0.0, 1.0).
   */
  w.random = function() {
    return Math.random();
  };

  /**
   * Choose a random integer in the range of [start, end).
   * &lt;p>
   * If end is not passed, the range will be [0, start).
   *
   * @param {number} start start of the range.
   * @param {number} stop end of the range.
   * @return {number} A random integer in the range.
   */
  w.randomInt = function(start, stop) {
    if (start === undefined &amp;&amp; stop === undefined) {
      return 0;
    } else if (stop === undefined) {
      stop = start;
      start = 0;
    }
    start = Math.ceil(start);
    stop = Math.ceil(stop);
    if (start &lt; stop) {
      return start + Math.floor((stop - start) * Math.random());
    } else if (start > stop) {
      return start - Math.floor((start - stop) * Math.random());
    } else {
      w.error('No integer in the range of [' + start + ', ' + stop + ')');
    }
  };

  /**
   * Choose a random floating-point number in the range of [start, end).
   * &lt;p>
   * If end is not passed, the range will be [0, start).
   *
   * @param {number} start start of the range.
   * @param {number} end end of the range.
   * @return {number} A random number in the range.
   */
  w.randomFloat = function(start, stop) {
    if (start === undefined &amp;&amp; stop === undefined) {
      return Math.random();
    } else if (stop === undefined) {
      return Math.random() * start;
    } else if (start &lt; stop) {
      return start + Math.random() * (stop - start);
    } else if (start > stop) {
      return start - Math.random() * (start - stop);
    } else {
      w.error('No number in the range of [' + start + ', ' + stop + ')');
    }
  };

  /**
   * Generate a random string.
   * &lt;p>
   * By default, the string may contain some of the these characters:
   * &lt;code>abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789&lt;/code>.
   * And by default, the string has 8 characters.
   *
   * @param {number} length The length of the string. Default to 8.
   * @param {string} allowedChars The allowed characters in the string.
   */
  w.randomString = function(length, allowedChars) {
    if (length === undefined) {
      length = 8;
    } else {
      length = w.i(length);
      length = w.max(length, 0);
    }
    if (allowedChars === undefined) {
      allowedChars = 'abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    } else {
      allowedChars = w.str(allowedChars);
    }
    var res = '';
    var len = allowedChars.length;
    for (var i = 0; i &lt; length; i++) {
      res += allowedChars[Math.floor(Math.random() * len)];
    }
    return res;
  };

  w.Queue = (function() {

    /**
     * Queue class. A Queue is a FIFO (First In, First Out) collection.
     *
     * @class
     * @name warmsea.Queue
     * @param {?function} validator A value validation function.
     */
    var Queue = function(validator) {
      this._validator = validator;
      this.clear();
      this.allowEmptyDequeue = true;
    };

    Object.defineProperty(Queue.prototype, 'length', {
      enumerable: true,
      get: function() {
        return this._queue.length - this._offset;
      }
    });

    /**
     * Remove all objects from the Queue.
     *
     * @method
     * @name warmsea.Queue.prototype.clear
     */
    Queue.prototype.clear = function() {
      this._queue = [];
      this._offset = 0;
    };

    /**
     * Add an object to the end of the Queue.
     *
     * @method
     * @name warmsea.Queue.prototype.enqueue
     * @param {Object} value An object.
     * @throws {Error} If value can't pass the validation.
     */
    Queue.prototype.enqueue = function(value) {
      if (this._validator &amp;&amp; !this._validator(value)) {
        w.error('Value not accepted: ' + value);
      }
      this._queue.push(value);
    };

    /**
     * Remove the object at the beginning of the Queue and return it.
     *
     * @method
     * @name warmsea.Queue.prototype.dequeue
     * @return {*} The object at the beginning of the Queue.
     */
    Queue.prototype.dequeue = function() {
      if (this.length === 0) {
        if (this.allowEmptyDequeue) {
          return undefined;
        } else {
          w.error('The queue is empty');
        }
      }
      var item = this._queue[this._offset++];
      if (this._offset > 16 &amp;&amp; this._offset * 2 > this._queue.length) {
        this._queue = this._queue.slice(this._offset);
        this._offset = 0;
      }
      return item;
    };

    /**
     * Return the object at the beginning of the Queue without removing it.
     *
     * @method
     * @name warmsea.Queue.prototype.peek
     * @return {*} The object at the beginning of the Queue.
     */
    Queue.prototype.peek = function() {
      if (this.length === 0) {
        if (this.allowEmptyDequeue) {
          return undefined;
        } else {
          w.error('Dequeueing an empty queue is not allowed');
        }
      }
      return this._queue[this._offset];
    };

    return Queue;

  })();

  w.Stack = (function() {

    /**
     * Stack class. A Stack is a FILO (First In, Last Out) collection.
     *
     * @class
     * @name warmsea.Stack
     * @param {?function} validator A value validation function.
     */
    var Stack = function(validator) {
      this._validator = validator;
      this.clear();
      this.allowEmptyPop = true;
    };

    Object.defineProperty(Stack.prototype, 'length', {
      enumerable: true,
      get: function() {
        return this._top + 1;
      }
    });

    /**
     * Remove all objects from the Stack.
     *
     * @method
     * @name warmsea.Stack.prototype.clear
     */
    Stack.prototype.clear = function() {
      this._stack = [];
      this._top = -1;
    };

    /**
     * Add an object to the top of the Stack.
     *
     * @method
     * @name warmsea.Stack.prototype.push
     * @param {Object} value An object.
     * @throws {Error} If value can't pass the validation.
     */
    Stack.prototype.push = function(value) {
      if (this._validator &amp;&amp; !this._validator(value)) {
        w.error('Value not accepted: ' + value);
      }
      this._top++;
      if (this._top &lt; this.length) {
        this._stack[this._top] = value;
      } else {
        this._stack.push(value);
      }
    };

    /**
     * Remove the object at the top of the Stack and return it.
     *
     * @method
     * @name warmsea.Stack.prototype.pop
     * @return {*} The object at the top of the Stack.
     */
    Stack.prototype.pop = function() {
      if (this.length === 0) {
        if (this.allowEmptyPop) {
          return undefined;
        } else {
          w.error('The stack is empty');
        }
      }
      var item = this._stack[this._top--];
      if (this._top > 16 &amp;&amp; this._top * 2 &lt; this._stack.length) {
        this._stack = this._stack.slice(0, this._top + 1);
      }
      return item;
    };

    /**
     * Return the object at the top of the Stack without removing it.
     *
     * @method
     * @name warmsea.Stack.prototype.peek
     * @return {*} The object at the top of the Stack.
     */
    Stack.prototype.peek = function() {
      if (this.length === 0) {
        if (this.allowEmptyPop) {
          return undefined;
        } else {
          w.error('Popping an empty stack is not allowed');
        }
      }
      return this._stack[this._top];
    };

    return Stack;

  })();



  if (typeof module === 'object' &amp;&amp; typeof module.exports === 'object') {
    module.exports = w;
  } else if ( typeof define === 'function' &amp;&amp; define.amd) {
    define(function() {
      return w;
    });
  } else {
      global.warmsea = w;
  }

})(this);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="warmsea.Queue.html">Queue</a></li><li><a href="warmsea.Stack.html">Stack</a></li></ul><h3>Namespaces</h3><ul><li><a href="warmsea.html">warmsea</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha4</a> on Sat May 03 2014 15:16:07 GMT+0800 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
